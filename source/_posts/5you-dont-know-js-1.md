---
title: 你不知道的JavaScript（上卷）读书笔记
tags:
  - study notes
date: 2018-11-20 17:24:37
updated: 2018-12-10 12:04:21
categories: study notes #文章分类
---
<img src="./ydkjs.jpg" width="250px">
本文记录了我在[豆瓣读书](https://read.douban.com/ebook/12051836/ "你不知道的JavaScript（上卷）")阅读《你不知道的JavaScript（上卷）》的过程中，对一些重要的内容进行的划线和批注，经常来看看，巩固巩固基础。
<!-- more -->
---

## 章节：1.2　理解作用域


> LHS

Left-Hand-Side


> RHS

Right-Hand-Side


## 章节：4.1　先有鸡还是先有蛋


> 考虑另外一段代码：

打印漏了，原书是： var a; console.log(a); a=2;


## 章节：4.2　编译器再度来袭


> 正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。


> 当你看到var a = 2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。


> 这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。
> 换句话说，先有蛋（声明）后有鸡（赋值）。


> 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。


> 函数声明会被提升，但是函数表达式却不会被提升。


## 章节：4.3　函数优先


> 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。


> 尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。


> 尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

又漏印了，最前面少一行代码： foo(); // 3


## 章节：4.4　小结


> 我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。


> 意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。


> 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。


## 章节：5.2　实质问题


> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。


> 闭包使得函数可以继续访问定义时的词法作用域。


## 章节：5.3　现在我懂了


> 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！


## 章节：5.6　小结


> 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。


> 闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。


> 模块有两个主要特征：(1)为创建内部作用域而调用了一个包装函数；(2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。


## 章节：附录C　 this 词法


> 箭头函数在涉及this绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this本来的值。


## 章节：1.2　误解


> this在任何情况下都不指向函数的词法作用域


## 章节：1.3　 this 到底是什么


> this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。


## 章节：1.4　小结


> 学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，你也许被这样的解释误导过，但其实它们都是错误的


> this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。


## 章节：2.1　调用位置


> 调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）


> 寻找调用位置就是寻找“函数被调用的位置”


> 最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中


> 绝大多数现代桌面浏览器都内置了开发者工具，其中包含JavaScript调试器。就本例来说，你可以在工具中给foo()函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条debugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析this的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。


## 章节：2.2　绑定规则


> 我们来看看在函数的执行过程中调用位置如何决定this的绑定对象。
> 你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条

默认绑定 隐式绑定 显示绑定 new绑定


> 2.2.1　默认绑定
> 首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。


> foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。


> 2.2.2　隐式绑定
> 另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，


> 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。


> 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。


> 隐式丢失
> 一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定


> 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。


> 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值


> 2.2.3　显式绑定


> 这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时指定这个this。因为你可以直接指定this的绑定对象，因此我们称之为显式绑定。

call() / apply()


> 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原始值会被转换成它的对象形式（也就是new String(..)、new Boolean(..)或者new Number(..)）。这通常被称为“装箱”。


> 1. 硬绑定


> 硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：


> 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind


> bind(..)会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。


> 2. API调用的“上下文”


> 第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。


> 2.2.4　new绑定


> 在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类时会调用类中的构造函数。

注意：说的是在传统面向类的语言中！


> 绝大多数开发者都认为JavaScript中new的机制也和那些语言一样。然而，JavaScript中new的机制实际上和面向类的语言完全不同。


> 首先我们重新定义一下JavaScript中的“构造函数”。JavaScript，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。


> 包括内置对象函数（比如Number(..)，详情请查看第3章）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。


> 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。
> 1. 创建（或者说构造）一个全新的对象。
> 2. 这个新对象会被执行[[原型]]连接。
> 3. 这个新对象会绑定到函数调用的this。
> 4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。
> + js 高程写的：
> 1. 创建一个新对象
> 2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
> 3. 执行构造函数中的代码（为这个新对象添加属性）
> 4. 返回这个新对象



## 章节：2.3　优先级


> 默认绑定的优先级是四条规则中最低的


> 显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。


> new绑定比隐式绑定优先级高


> MDN提供的一种bind(..)实现

bind实现


> 可以按照下面的顺序来进行判断：
> 1. 函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。
> var bar = new foo()
> 2. 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。
> var bar = foo.call(obj2)
> 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。
> var bar = obj1.foo()
> 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
> var bar = foo()
> 就是这样。


## 章节：3.1　语法


> 对象可以通过两种形式定义：声明（文字）形式和构造形式。


## 章节：3.2　类型


> 对象是JavaScript的基础。在JavaScript中一共有六种主要类型（术语是“语言类型”）：
> • string
> • number
> • boolean
> • null
> • undefined
> • object


> 注意，简单基本类型（string、boolean、number、null和undefined）本身并不是对象


> 有一种常见的错误说法是“JavaScript中万物皆是对象”，这显然是错误的。


> 构造函数（由new产生的函数调用


> 我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成String对象，所以可以访问属性和方法。


> null和undefined没有对应的构造形式，它们只有文字形式。相反，Date只有构造，没有文字形式。


> 对于Object、Array、Function和RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。


## 章节：3.3　内容


> ES6增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当作属性名


> ES6定义了Object.assign(..)方法来实现浅复制。Object.assign(..)方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举（enumerable，参见下面的代码）的自有键（owned key，很快会介绍）并把它们复制（使用=操作符赋值）到目标对象，最后返回目标对象


> 它还包含另外三个特性：writable（可写）、enumerable（可枚举）和configurable（可配置）。


> 在创建普通属性时属性描述符会使用默认值，我们也可以使用Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。


> 1. Writable
> writable决定是否可以修改属性的值。


> 2. Configurable
> 只要属性是可配置的，就可以使用defineProperty(..)方法来修改属性


> 3. Enumerable


> myObject.a在myObject上实际上是实现了[[Get]]操作（有点像函数调用：[[Get]]()）


## 章节：4.1　类理论


> 其他语言中的类和JavaScript中的“类”并不一样


## 章节：4.2　类的机制


> 类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。


## 章节：4.3 类的继承


> 这个技术被称为多态或者虚拟多态。在本例中，更恰当的说法是相对多态。


## 章节：5.1　 [[Prototype]] 


> JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。


> Object.create(..)的原理，现在只需要知道它会创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。


> 使用for..in遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到（并且是enumerable，参见第3章）的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）


> 所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。


> 你希望在第二种和第三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty(..)（参见第3章）来向myObject添加foo。


## 章节：5.2　“类”


> 因为根本就不存在类


> 再说一遍，JavaScript中只有对象


> 所有的函数默认都会拥有一个名为prototype的公有并且不可枚举（参见第3章）的属性，它会指向另一个对象：
> function Foo() { 
>     // ...
> }
> 
> Foo.prototype; // { }
> 这个对象通常被称为Foo的原型，因为我们通过名为Foo.prototype的属性引用来访问它。


> 这个对象是在调用new Foo()（参见第2章）时创建的，最后会被（有点武断地）关联到这个“Foo点prototype”对象上


> 调用new Foo()时会创建a（具体的4个步骤参见第2章），其中的一步就是给a一个内部的[[Prototype]]链接，关联到Foo.prototype指向的那个对象。


> 你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。


> new Foo()这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo()只是间接完成了我们的目标：一个关联到其他对象的新对象。


> Foo.prototype默认（在代码中第一行声明时！）有一个公有并且不可枚举（参见第3章）的属性.constructor，这个属性引用的是对象关联的函数（本例中是Foo）


> 这很令人吃惊，我们竟然会如此努力地维护JavaScript中（假）“面向类”的权力，尽管对于JavaScript引擎来说首字母大写没有任何意义。


> 实际上，Foo和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上new关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new会劫持所有普通函数并用构造对象的形式来调用它。


> ，在JavaScript中对于“构造函数”最准确的解释是，所有带new的函数调用。


> 函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”


> 之前讨论.constructor属性时我们说过，看起来a.constructor === Foo为真意味着a确实有一个指向Foo的.constructor属性，但是事实不是这样。
> 这是一个很不幸的误解。实际上，.constructor引用同样被委托给了Foo.prototype，而Foo.prototype.constructor默认指向Foo。
> 把.constructor属性指向Foo看作是a对象由Foo“构造”非常容易理解，但这只不过是一种虚假的安全感。a.constructor只是通过默认的[[Prototype]]委托指向Foo，这和“构造”毫无关系。相反，对于.constructor的错误理解很容易对你自己产生误导。
> 举例来说，Foo.prototype的.constructor属性只是Foo函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的.prototype对象 […]


> .constructor并不是一个不可变属性。它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改）。


> a1.constructor是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。


## 章节：5.3　（原型）继承


> 如果忽略掉Object.create(..)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比ES6及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。


> 假设有对象a，如何寻找对象a委托的对象（如果存在的话）呢？在传统的面向类环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省（或者反射）


> instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？


> instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？

instanceof


> 可惜，这个方法只能处理对象（a）和函数（带.prototype引用的Foo）之间的关系。如果你想判断两个对象（比如a和b）之间是否通过[[Prototype]]链关联，只用instanceof无法实现。


> 如果使用内置的.bind(..)函数来生成一个硬绑定函数（参见第2章）的话，该函数是没有.prototype属性的。在这样的函数上使用instanceof的话，目标函数的.prototype会代替硬绑定函数的.prototype。


> 通常我们不会在“构造函数调用”中使用硬绑定函数，不过如果你这么做的话，实际上相当于直接调用目标函数。同理，在硬绑定函数上使用instanceof也相当于直接在目标函数上使用instanceof。


> 下面是第二种判断[[Prototype]]反射的方法，它更加简洁：
> Foo.prototype.isPrototypeOf( a ); // true
> 注意，在本例中，我们实际上并不关心（甚至不需要）Foo，我们只需要一个可以用来判断的对象（本例中是Foo.prototype）就行。isPrototypeOf(..)回答的问题是：在a的整条[[Prototype]]链中是否出现过Foo.prototype？


> 我们只需要两个对象就可以判断它们之间的关系。举例来说：
> // 非常简单：b是否出现在c的[[Prototype]]链中？
> b.isPrototypeOf( c );
> 注意，这个方法并不需要使用函数（“类”），它直接使用b和c之间的对象引用来判断它们的关系。换句话说，语言内置的isPrototypeOf(..)函数就是我们的isRelatedTo(..)函数。


> 这个奇怪的.__proto__（在ES6之前并不是标准！）属性“神奇地”引用了内部的[[Prototype]]对象，如果你想直接查找（甚至可以通过.__proto__.__ptoto__...来遍历）原型链的话，这个方法非常有用。
> 和我们之前说过的.constructor一样，.__proto__实际上并不存在于你正在使用的对象中（本例中是a）。实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的Object.prototype中。


> JavaScript社区中对于双下划线有一个非官方的称呼，他们会把类似__proto__的属性称为“笨蛋（dunder）”。所以，JavaScript潮人会把__proto__叫作“笨蛋proto”。


## 章节：5.4　对象关联


> 现在我们知道了，[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象。
> 通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。


> 我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。


> 我并不赞同这个严格的观点，相反，我很赞同在ES5中使用上面那段polyfill代码。如何选择取决于你。


> 在ES6中有一个被称为“代理”（Proxy）的高端功能，它实现的就是“方法无法找到”时的行为。


> 千万不要忽略这个微妙但是非常重要的区别。


> 但是你可以让你的API设计不那么“神奇”，同时仍然能发挥[[Prototype]]关联的威力：
> var anotherObject = { 
>     cool: function() {
>         console.log( "cool!" );
>     }
> };
> 
> var myObject = Object.create( anotherObject );
> 
> myObject.doCool = function() { 
>     this.cool(); // 内部委托！
> };
> 
> myObject.doCool(); // "cool!"
> 这里我们调用的myObject.doCool()是实际存在于myObject中的，这可以让我们的API设计更加清晰（不那么“神奇”）。从内部来说，我们的实现遵循的是委托设计模式（参见第6章），通过[[Prototype]]委托到anotherObj […]


## 章节：5.5　小结


> 所有普通对象都有内置的Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。


> 关联两个对象最常用的方法是使用new关键词进行函数调用，在调用的4个步骤（第2章）中会创建一个关联其他对象的新对象。
> 使用new调用函数时会把新对象的.prototype属性关联到“其他对象”。带new的函数调用通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。


> 虽然这些JavaScript机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是JavaScript中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的[[Prototype]]链关联的。
> 出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无法帮助你理解JavaScript的真实机制（不仅仅是限制我们的思维模式）。
> 相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。


## 章节：第 6 章　行为委托


> 不出意外，绝大多数JavaScript开发者从来没有如此深入地了解过JavaScript，他们只是把这些交给一个“类”库来处理。


> [[Prototype]]机制就是指对象中的一个内部链接引用另一个对象。


> 如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。


> 如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。

划重点


> JavaScript中这个机制的本质就是对象之间的关联关系。


## 章节：6.1　面向委托的设计


> 我们需要试着把思路从类和继承的设计模式转换到委托行为的设计模式。


> 非常重要的是，类设计模式鼓励你在继承时使用方法重写（和多态），比如说在XYZ任务中重写Task中定义的一些通用方法，甚至在添加新行为时通过super调用这个方法的原始版本。你会发现许多行为可以先“抽象”到父类然后再用子类进行特殊化（重写）。


> 首先你会定义一个名为Task的对象（和许多JavaScript开发者告诉你的不同，它既不是类也不是函数），它会包含所有任务都可以使用（写作使用，读作委托）的具体行为。接着，对于每个任务（“XYZ”、“ABC”）你都会定义一个对象来存储对应的数据和行为。你会把特定的任务对象都关联到Task功能对象上，让它们在需要的时候可以进行委托。


> 相比于面向类（或者说面向对象），我会把这种编码风格称为“对象关联”（OLOO，objects linked to other objects）。我们真正关心的只是XYZ对象（和ABC对象）委托了Task对象。


> 相比于面向类（或者说面向对象），我会把这种编码风格称为“对象关联”（OLOO，objects linked to other objects）。我们真正关心的只是XYZ对象（和ABC对象）委托了Task对象。

OLOO objects linked to other objects


> 无论你多么努力地说服自己，JavaScript中就是没有类似“类”的抽象机制


> 1. 在上面的代码中，id和label数据成员都是直接存储在XYZ上（而不是Task）。通常来说，在[[Prototype]]委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。
> 2. 在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有outputTask方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义（参见第4章）。


> 这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。


> 委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）


> 这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。


> 这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。

记住这个描述


> 1. 互相委托（禁止）
> 你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把B关联到A然后试着把A关联到B，就会出错。


> 2. 调试


> 首先，类风格代码的思维模型强调实体以及实体间的关系：


> JavaScript中的函数之所以可以访问call(..)、apply(..)和bind(..)（参见第2章），就是因为函数本身是对象。而函数对象同样有[[Prototype]]属性并且关联到Function.prototype对象，因此所有函数对象都可以通过委托调用这些默认方法。JavaScript能做到这一点，你也可以！


> 通过比较可以看出，对象关联风格的代码显然更加简洁，因为这种代码只关注一件事：对象之间的关联关系。


## 章节：6.2　类与对象


> 使用类构造函数的话，你需要（并不是硬性要求，但是强烈建议）在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开（就像对象关联代码一样）更灵活。


> 对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要合并为一个步骤。


## 章节：6.3　更简洁的设计


> 所有控制器共享的基础行为是success(..)、failure(..)和showDialog(..)。子类LoginController和AuthController通过重写failure(..)和success(..)来扩展默认基础类行为。此外，注意AuthController需要一个LoginController的实例来和登录表单进行交互，因此这个实例变成了一个数据属性。
> 另一个需要注意的是我们在继承的基础上进行了一些合成。AuthController需要使用LoginController，因此我们实例化后者（new LoginController()）并用一个类成员属性this.login来引用它，这样AuthController就可以调用LoginController的行为。

上面👆代码最后实例化的部分写错了，特意翻了纸质版原书，果然写错了，正确的是这样： var auth = new AuthController( new LoginController() );  auth.checkAuth();


> 由于AuthController只是一个对象（LoginController也一样），因此我们不需要实例化（比如new AuthController()），只需要一行代码就行：


> 这种模式的重点在于只需要两个实体（LoginController和AuthController），而之前的模式需要三个。


> 我们不需要Controller基类来“共享”两个实体之间的行为，因为委托足以满足我们需要的功能。同样，前面提到过，我们也不需要实例化类，因为它们根本就不是类，它们只是对象。此外，我们也不需要合成，因为两个对象可以通过委托进行合作。


> 总结：我们用一种（极其）简单的设计实现了同样的功能，这就是对象关联风格代码和行为委托设计模式的力量。


## 章节：6.4　更好的语法


> 在ES6中我们可以在任意对象的字面形式中使用简洁方法声明（concise method declaration），所以对象关联风格的对象可以这样声明（和class的语法糖一样）：
> var LoginController = { 
>     errors: [],
>     getUser() { // 妈妈再也不用担心代码里有function了！
>         // ...
>     },
>     getPassword() {
>         // ...
>     }
>     // ...
> };
> 唯一的区别是对象的字面形式仍然需要使用“,”来分隔元素，而class语法不需要。这个区别对于整体的设计来说无关紧要。


> 使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数（·baz: function baz(){..}·），不要使用简洁方法。


## 章节：6.5　内省


> 自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。


> 因为Foo.prototype（不是Foo！）在a1的[[Prototype]]链上（参见第5章）


> 再说一次，我们认为JavaScript中对象关联比类风格的代码更加简洁（而且功能相同）。


## 章节：6.6　小结


> 在软件架构中你可以选择是否使用类和继承设计模式。大多数开发者理所当然地认为类是唯一（合适）的代码组织方式，但是本章中我们看到了另一种更少见但是更强大的设计模式：行为委托。


> 行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在JavaScript中努力实现类机制（参见第4和第5章），也可以拥抱更自然的[[Prototype]]委托机制。


> 当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。


> 对象关联（对象之前互相关联）是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于[[Prototype]]的行为委托非常自然地实现。


## 章节：附录A　ES6中的Class


> 类是一种可选（而不是必须）的设计模式，而且在JavaScript这样的[[Prototype]]语言中实现类是很别扭的。


> 类并不适用于JavaScript。


## 章节：A.1　 class 


> 除了语法更好看之外，ES6还解决了什么问题呢？
> 1.（基本上，下面会详细介绍）不再引用杂乱的.prototype了。  
> 2. Button声明时直接“继承”了Widget，不再需要通过Object.create(..)来替换.prototype对象，也不需要设置.__proto__或者Object.setPrototypeOf(..)。  
> 3. 可以通过super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。这可以解决第4章提到过的那个问题：构造函数不属于类，所以无法互相引用——super()可以完美解决构造函数的问题。  
> 4. class字面语法不能声明属性（只能声明方法）。看起来这是一种限制，但是它会排除掉许多不好的情况，如果没有这种限制的话，原型链末端的“实例”可能会意外地获取其他地方的属性（这些属性隐式被所有“实例”所“共享”）。所以，class语法实际 […]


## 章节：A.2　 class 陷阱


> 首先，你可能会认为ES6的class语法是向JavaScript中引入了一种新的“类”机制，其实不是这样。class基本上只是现有[[Prototype]]（委托！）机制的一种语法糖。


> class并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你（有意或无意）修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于[[Prototype]]的实时委托：


> ES6中的class语法不是会让传统类和委托对象之间的区别更加难以发现和理解吗？

思考


> 无论目前的方法在原型链中处于什么位置，super总会绑定到链中的上一层。


> 然而，出于性能考虑（this绑定已经是很大的开销了），super并不是动态绑定的，它会在声明时“静态”绑定


> 出于性能考虑，super并不像this一样是晚绑定（late bound， 或者说动态绑定）的，它在[[HomeObject]].[[Prototype]]上，[[HomeObject]]会在创建时静态绑定。


## 章节：A.3　静态大于动态吗


> 在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但是JavaScript最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你把它设置成不可变）。


> 换句话说，class似乎想告诉你：“动态太难实现了，所以这可能不是个好主意。这里有一种看起来像静态的语法，所以编写静态代码吧。”


> 动态太难实现了，我们假装成静态吧。（但是实际上并不是！）


> 总地来说，ES6的class想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让JavaScript更加难以理解。


## 章节：A.4　小结


> class很好地伪装成JavaScript中类和继承设计模式的解决方案，但是它实际上起到了反作用：它隐藏了许多问题并且带来了更多更细小但是危险的问题。


> class加深了过去20年中对于JavaScript中“类”的误解，在某些方面，它产生的问题比解决的多，而且让本来优雅简洁的[[Prototype]]机制变得非常别扭。


> 如果ES6的class让[[Prototype]]变得更加难用而且隐藏了JavaScript对象最重要的机制——对象之间的实时委托关联，我们难道不应该认为class产生的问题比解决的多吗？难道不应该抵制这种设计模式吗？